

单例模式：
    1.懒汉模式
        饿汉模式再类加载的时候就立即初始化，并创建单例对象
              优点：
                   1.没有任何的锁，执行效率非常高
                   2.在用户体验上比懒汉式更好
                   3.绝对的线程安全，在线程还没有出现的时候就初始化好了，不存在访问的安全问题
              缺点：
                   1.类加载的时候就初始化，不管是否使用。  浪费资源

    2.恶汉模式
        1.静态内部类懒汉单例模式
        2.懒汉单例模式

    3.容器缓存法的单例模式
        Spring中的做法，就是用这种注册式单例(容器缓存的写法)
        讲对象放入ConcurrentHashMap中，并进行加锁判断，不存在，就通过反射创建对象添加，存在，就直接获取对象

    4.枚举单例
        通常在通用API中使用

    5.反序列化破坏单例
           //序列化就是说把内存中的状态通过转换成字节码的形式
           //从而转换一个IO流，写入到其他地方(可以是磁盘、网络IO)
           //内存中状态给永久保存下来了

           //反序列化
           //讲已经持久化的字节码内容，转换为IO流
           //通过IO流的读取，进而将读取的内容转换为Java对象
           //在转换过程中会重新创建对象new

       反序列化时导致单例被破坏 成多例 （将对象序列化Serializble,并写出流，重新读取到程序，就会形成多例）
            反序列化破坏单例的重要部分：
                /**
                     * 4.重新readResolve方法，对反序列化对象赋值为当前单例的唯一对象
                     *  返回类型：Object
                     */

                    private Object readResolve(){
                        return  INSTANCE;
                    }

    5.防止反射破坏单例
        单例对象可以通过反射进行重新实例化对象
        避免反射注意地方：
            //1.私有化构造
                private SerializbleSingletonPattern(){
                    //防止反射 （INSTANCE：当前类的对象名，进行判断，如果存在就抛出异常）
                    if(INSTANCE != null){
                        throw new RuntimeException("单例对象，不允许创建多个实例！");
                    }
                }